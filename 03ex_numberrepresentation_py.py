# -*- coding: utf-8 -*-
"""03ex_numberRepresentation.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_2sGchNPo7ozMyDFKz66REKKTq62tjMx
"""

#EX1
import math
import sys

def convert(x,y):
	if isinstance(x,int)==0:
		s=str(x)
		try:
			x=int(s,2)
		except:
			x=int(st,16)
	if y=="bin":
		return bin(x)
	if y=="hex":
		return hex(x)
	if y=="dec":
		return x
	else:
		print("Invalid output type")
a=12
b=convert(a,"hex")
print(b)
c=convert(a,"bin")
print(c)
d=bin(a)
e=convert(d,"dec")
print(e)

#EX2
def floatPointNum(bin_str):
    sign_bin = int(bin_str[0])
    exp_bin = int(bin_str[1:9],2)
    mant_bin = int("1"+bin_str[9:], 2)

    return (-1)**sign_bin * mant_bin /( 1<<( len(bin_str)-9 - (exp_bin-127) ))

bin_str = "110000101011000000000000"
bin_str = bin_str.zfill(32)
print(floatPointNum(bin_str))

#EX3
a=1
b=1
while float(a*2)<float('inf'):
    a=float(a*2)
print(a)
while (b/2)>0:
    b=b/2
print(b)

#EX4
pr=5.0
while pr+1>1:
    pr=float(pr/2)
pr=pr*2
print(pr)

#EX5
import math
#a

def qSol1(a,b,c):
    if((b**2)-(4*a*c)<0):
        print("Can not resolve the quadratic equation because the solutions are complex")
        return
    delta_sqrt = math.sqrt((b**2)-(4*a*c))
    x1 = (-b+delta_sqrt)/ (2*a)
    x2 = (-b-delta_sqrt)/ (2*a)
    return x1,x2


sola1,sola2 = qSol1(5,3,0.001)
print("result a1: "+str(sola1))
print("result a2: "+str(sola2))

#b
def qSol2(a,b,c):
    if((b**2)-(4*a*c)<0):
        print("Can not resolve the quadratic equation because the solutions are complex")
        return
    delta_sqrt = math.sqrt((b**2)-(4*a*c))
    x1 = ((-b+delta_sqrt)*(-b-delta_sqrt)) / ((2*a)*(-b-delta_sqrt))
    x2 = ((-b-delta_sqrt)*(-b+delta_sqrt)) / ((2*a)*(-b+delta_sqrt))
    return x1,x2


solb1,solb2 = qSol2(5,3,0.001)
print("result b1: "+str(solb1))
print("result b2: "+str(solb2))



#EX6
def f(x):
    return x*(x-1)
delta=0.01
der= (f(1+delta)-f(1))/delta
print(der)

#EX7
#a
import timeit
def semicircle(n):
    if(n==0):
        print("data is not correct")
        return
    h=2/n
    integral=0
    x=-1
    for i in range(n):
        integral=integral+(h*math.sqrt(1-x**2))
        x=x+h
    return integral

print("The integral for n=100 is=", semicircle(100))

#b

semicircle(100)
k=100
while(True):
    start_time=timeit.default_timer()
    semicircle(k)
    end_time=timeit.default_timer()
    comp_time=end_time-start_time
    if(comp_time>=1):
        break
    if(comp_time<0.5):
        k=k*2
    elif(0.5<=comp_time<0.9):
        k=int(k*1.5)
    elif(comp_time>=0.9):
        k=k+1

print(k-1) #k-1 because i stop when i take 1 second or more